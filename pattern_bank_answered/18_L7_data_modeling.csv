question_id,question_text,priority,pattern_id,pattern_name,solving_formula,notes,short_answer
279,Design a color propensity model for sponsored products ads at Amazon.,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,ML model design; advertising,"Entities: Identify core nouns in the business. Core entities: User, Product, Order, Order_Item, Session, Payment. Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Examples: User â†’ Orders (1:N), Order â†’ Order_Items (1:N), Order_Items â†’ Product (M:N via Order_Items). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. Example metrics: Revenue (sum of order amounts), Order count, Conversion rate (orders/sessions). 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Example: fact_orders table = 1 row per order. fact_sessions table = 1 row per session. Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
289,Design a Data Warehouse Schema for a Ride-Sharing Service,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,Data warehouse design; ride-sharing,"Entities: Identify core nouns in the business. Core entities: User (rider), Driver, Trip, Vehicle, Payment. Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Examples: User â†’ Trips (1:N), Driver â†’ Trips (1:N), Trip â†’ Payment (1:1). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. Example metrics: Trip count, Revenue (sum of trip fares), Average trip distance. 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Example: fact_trips table = 1 row per trip. fact_events table = 1 row per event (request, accept, complete). Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
290,Design a Data Warehouse Schema for Airbnb,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,Data warehouse design; Airbnb,"Entities: Identify core nouns in the business. Core entities: Identify main business objects (Users, Transactions, Events, Products, etc.). Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
291,Design a data warehouse schema for Amazon.,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,Data warehouse design; Amazon,"Entities: Identify core nouns in the business. Core entities: User, Product, Order, Order_Item, Session, Payment. Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Examples: User â†’ Orders (1:N), Order â†’ Order_Items (1:N), Order_Items â†’ Product (M:N via Order_Items). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. Example metrics: Revenue (sum of order amounts), Order count, Conversion rate (orders/sessions). 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Example: fact_orders table = 1 row per order. fact_sessions table = 1 row per session. Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
292,Design a Data Warehouse Schema for Customer Support,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,Data warehouse design; customer support,"Entities: Identify core nouns in the business. Core entities: Identify main business objects (Users, Transactions, Events, Products, etc.). Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
293,Design a data warehouse schema for Instagram.,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,Data warehouse design; Instagram,"Entities: Identify core nouns in the business. Core entities: User, Post, Comment, Like, Follow, Session. Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Examples: User â†’ Posts (1:N), User â†’ Likes (M:N via Likes table), User â†’ Follows (M:N via Follows table). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. Example metrics: Post count, Engagement rate (likes/posts), Active users. 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Example: fact_posts table = 1 row per post. fact_events table = 1 row per user action (like, comment). Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
294,Design a data warehouse schema for LinkedIn.,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,Data warehouse design; LinkedIn,"Entities: Identify core nouns in the business. Core entities: User, Post, Comment, Like, Follow, Session. Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Examples: User â†’ Posts (1:N), User â†’ Likes (M:N via Likes table), User â†’ Follows (M:N via Follows table). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. Example metrics: Post count, Engagement rate (likes/posts), Active users. 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Example: fact_posts table = 1 row per post. fact_events table = 1 row per user action (like, comment). Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
295,Design a data warehouse schema for Spotify.,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,Data warehouse design; Spotify,"Entities: Identify core nouns in the business. Core entities: Identify main business objects (Users, Transactions, Events, Products, etc.). Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
296,Design a Data Warehouse Schema for Stripe,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,Data warehouse design; Stripe,"Entities: Identify core nouns in the business. Core entities: User (rider), Driver, Trip, Vehicle, Payment. Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Examples: User â†’ Trips (1:N), Driver â†’ Trips (1:N), Trip â†’ Payment (1:1). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. Example metrics: Trip count, Revenue (sum of trip fares), Average trip distance. 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Example: fact_trips table = 1 row per trip. fact_events table = 1 row per event (request, accept, complete). Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
297,Design a database schema for a fitness app.,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,Database schema; fitness app,"Entities: Identify core nouns in the business. Core entities: Identify main business objects (Users, Transactions, Events, Products, etc.). Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
298,Design a database schema for a ride sharing app.,ðŸŸ¡,L7,Data Modeling,Entities â†’ Relationships â†’ Metrics â†’ Grain â†’ Validate,Database schema; ride sharing,"Entities: Identify core nouns in the business. Core entities: User (rider), Driver, Trip, Vehicle, Payment. Rule: If it has its own lifecycle â†’ entity. Each entity represents a distinct business concept with its own attributes and lifecycle.

Relationships: Define how entities connect. One-to-one: single relationship (e.g., User â†’ Profile). One-to-many: parent-child (e.g., User â†’ Orders, User â†’ Sessions). Many-to-many: requires junction table (e.g., Order â†” Products via Order_Items). Examples: User â†’ Trips (1:N), Driver â†’ Trips (1:N), Trip â†’ Payment (1:1). Design relationships to support efficient queries and avoid data redundancy.

Metrics: Define what we measure. Counts: # orders, # sessions, # users, # events. Sums: Revenue, Spend, Total amount. Ratios: Conversion rate, Retention rate, Average order value. Rule: Metrics live on facts (fact tables), not dimensions. Facts store metrics; dimensions store context. Example metrics: Trip count, Revenue (sum of trip fares), Average trip distance. 

Grain: Define what one row represents. One row per: Event, Session, Order, User-day, Transaction. Rule: Never mix grains in one table. Grain is the most important decision - it determines what questions you can answer. Example: fact_trips table = 1 row per trip. fact_events table = 1 row per event (request, accept, complete). Model for questions, not for storage.

Validate: Verify the model can answer key questions. Can we compute metrics without double-counting? Check aggregation logic. Do joins stay clean? Verify relationships support efficient queries. Does aggregation feel natural? Can we easily roll up by time, user, product, etc.? Do edge cases break it? Test with nulls, duplicates, orphaned records. Output: Clean Fact + Dimension model. FACT tables: things that happen (events, orders, sessions). DIM tables: descriptions (users, products, time). If joins feel painful, the model is wrong."
