question_id,question_text,priority,pattern_id,pattern_name,solving_formula,notes,short_answer
230,Describe an endpoint and provide two examples.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API design; technical explanation,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
240,"Describe three behavioral leadership principles, two functional competencies, and one technical system design.",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Leadership and system design; mixed question,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
242,Describe what happens when you type a URL into your browser and press Enter.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System explanation; web architecture,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
245,Describe your experience with AWS for machine learning projects.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,AWS ML experience; technical background,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
247,Describe your experience with PyTorch.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,ML framework experience; technical background,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
249,Describe your GPU programming experience.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,GPU programming; technical background,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
251,Describe your machine learning experience.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,ML experience; technical background,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
254,"Design a 5:1 audio system for WhatsApp, Instagram, and Messenger, including hardware interfaces, codecs, API endpoints, and the value proposition for Meta.",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Audio system design; technical architecture,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: enable real-time communication between users reliably
  ğŸ“Š Success metric: message delivery latency, delivery guarantees, availability
  ğŸš« Non-goals: video calls, file sharing, group management (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: mobile apps, web clients sending/receiving messages
  ğŸ’¬ Message service: handle send, receive, delivery status
  ğŸ“¨ Message queue: Kafka/RabbitMQ for reliable delivery
  ğŸ’¾ Message store: database for message history and metadata
  ğŸ”” Presence service: track online/offline status, push notifications
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  âœï¸ Send: sender â†’ message service â†’ queue â†’ store â†’ push to recipient
  ğŸ“– Receive: recipient â†’ message service â†’ fetch from store â†’ deliver
  â³ Async: offline message delivery, read receipts, typing indicators
  âŒ Failure: message retry, dead letter queue, delivery status tracking
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: message delivery <1s for online users
  ğŸ”’ Consistency: at-least-once delivery guarantee, message ordering
  ğŸ“ˆ Throughput: 1M messages/sec, handle message bursts
  ğŸ’° Cost: optimize storage (message retention policies)
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: message queue, message store, push notification service
  âš ï¸ Single points: message queue, database, push service
  ğŸš¦ Backpressure: queue messages, rate limit sends, batch notifications
  ğŸ’¨ Caching: cache recent messages, user presence, connection state
  ğŸ”€ Sharding: shard by user_id, partition message queues
  âš ï¸ Rule: Talk about failure BEFORE optimization"
256,"Design a banking system to facilitate account creation, deposits, transfers, and listing the most active accounts by total monetary activity, with commands entered via parsing CSV/JSON.",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Banking system design; technical architecture,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
283,Design a currency exchange system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; currency exchange,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
299,Design a denoising system for sounds.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; audio processing,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
303,Design a distributed file system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; distributed file system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
305,Design a distributed training system for a trillion-parameter language model.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; ML training,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
306,Design a DNS cache.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; DNS cache,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
309,Design a fake news detection system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; content moderation,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
312,Design a file cache system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; caching,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
313,Design a file system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; file system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
324,Design a food truck's front-end and backend system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; food truck platform,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
345,Design a key-value store.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; key-value store,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
347,Design a language detection system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; language detection,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
350,Design a leaderboard system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; leaderboard,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
356,Design a machine learning system that makes stock predictions from Reddit comments.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; ML prediction,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
363,Design a microservices architecture using Java Spring Boot.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; microservices,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
366,Design a module to fetch a unique User ID from a pool of available User IDs and return the ID to the pool for later use.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; ID pool management,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
370,Design a music player application using the MVC (Model-View-Controller) architecture.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; MVC architecture,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
379,Design a next word prediction system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; NLP prediction,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
387,"Design a peer-to-peer file distribution system that spreads a 10GB file from a single bandwidth-constrained source to thousands of interconnected hosts, each with limited input/output bandwidth, un...",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; P2P file distribution,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
389,Design a personalized news ranking system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; recommendation system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: surface relevant content/products to users based on preferences
  ğŸ“Š Success metric: click-through rate, engagement, relevance score, latency
  ğŸš« Non-goals: real-time updates, explainability, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile apps requesting recommendations
  ğŸ¯ Recommendation service: compute personalized rankings
  ğŸ‘¤ User profile store: user preferences, history, behavior
  ğŸ“¦ Item catalog: product/content metadata and features
  ğŸ¤– ML models: ranking algorithms, collaborative filtering, embeddings
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path: client â†’ API â†’ fetch user profile â†’ compute recommendations â†’ rank â†’ return
  âœï¸ Write path: user actions â†’ event stream â†’ update user profile â†’ retrain models (async)
  â³ Async: model training, feature computation, index updates
  âŒ Failure: model unavailable â†’ fallback to popularity-based, cache stale results
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: recommendations must be <100ms (user-facing)
  ğŸ”’ Consistency: eventual consistency OK (user profiles update async)
  ğŸ“ˆ Throughput: 1M requests/sec during peak, handle cold starts
  ğŸ’° Cost: balance model complexity vs inference cost
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: model inference, feature store lookups, ranking computation
  âš ï¸ Single points: model serving, feature store, user profile DB
  ğŸš¦ Backpressure: queue requests, return cached/stale recommendations
  ğŸ’¨ Caching: cache popular recommendations, pre-compute for hot users
  ğŸ”€ Sharding: shard user profiles, distribute model serving
  âš ï¸ Rule: Talk about failure BEFORE optimization"
453,Design a radar tower model for a moving ship.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; radar system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
454,Design a rate limiter for a microservices API.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; rate limiting,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
455,Design a rate limiter.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; rate limiting,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
456,Design a recommendation engine.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; recommendation engine,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: surface relevant content/products to users based on preferences
  ğŸ“Š Success metric: click-through rate, engagement, relevance score, latency
  ğŸš« Non-goals: real-time updates, explainability, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile apps requesting recommendations
  ğŸ¯ Recommendation service: compute personalized rankings
  ğŸ‘¤ User profile store: user preferences, history, behavior
  ğŸ“¦ Item catalog: product/content metadata and features
  ğŸ¤– ML models: ranking algorithms, collaborative filtering, embeddings
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path: client â†’ API â†’ fetch user profile â†’ compute recommendations â†’ rank â†’ return
  âœï¸ Write path: user actions â†’ event stream â†’ update user profile â†’ retrain models (async)
  â³ Async: model training, feature computation, index updates
  âŒ Failure: model unavailable â†’ fallback to popularity-based, cache stale results
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: recommendations must be <100ms (user-facing)
  ğŸ”’ Consistency: eventual consistency OK (user profiles update async)
  ğŸ“ˆ Throughput: 1M requests/sec during peak, handle cold starts
  ğŸ’° Cost: balance model complexity vs inference cost
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: model inference, feature store lookups, ranking computation
  âš ï¸ Single points: model serving, feature store, user profile DB
  ğŸš¦ Backpressure: queue requests, return cached/stale recommendations
  ğŸ’¨ Caching: cache popular recommendations, pre-compute for hot users
  ğŸ”€ Sharding: shard user profiles, distribute model serving
  âš ï¸ Rule: Talk about failure BEFORE optimization"
464,Design a reservation and payment system for a parking garage.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; parking system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: process transactions securely and reliably
  ğŸ“Š Success metric: transaction success rate, latency, fraud detection, availability
  ğŸš« Non-goals: refunds, disputes, multi-currency (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: merchants, payment gateways, mobile apps
  ğŸ’³ Payment processor: authorize, capture, settle transactions
  ğŸ¦ Bank gateway: communicate with payment networks
  ğŸ”’ Fraud detection: ML models to detect suspicious transactions
  ğŸ’¾ Transaction store: database for transaction history, reconciliation
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
465,"Design a restaurant application that gives the expected waiting time based on waiters, tables, and customers.",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; restaurant app,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
467,Design a Retrieval-Augmented Generation (RAG) system to help TikTok's content moderation team detect and handle misinformation.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; RAG for moderation,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
474,Design a search engine for Instagram.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; search engine,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: quickly find relevant results from large datasets
  ğŸ“Š Success metric: search latency, relevance, result ranking quality
  ğŸš« Non-goals: autocomplete, spell correction, personalization (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: search UI, API consumers
  ğŸ” Search service: query processing, ranking, result assembly
  ğŸ“š Index: inverted index, document store, ranking data
  ğŸ”„ Indexer: crawl, parse, and build search indexes
  ğŸ’¨ Cache: popular queries, autocomplete suggestions
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
476,Design a search system that adapts to constantly changing user interests.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; adaptive search,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: quickly find relevant results from large datasets
  ğŸ“Š Success metric: search latency, relevance, result ranking quality
  ğŸš« Non-goals: autocomplete, spell correction, personalization (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: search UI, API consumers
  ğŸ” Search service: query processing, ranking, result assembly
  ğŸ“š Index: inverted index, document store, ranking data
  ğŸ”„ Indexer: crawl, parse, and build search indexes
  ğŸ’¨ Cache: popular queries, autocomplete suggestions
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
478,"Design a service like Azure Key Vault that securely stores and retrieves secrets, certificates, and keys for applications and users.",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; security service,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
498,Design a system for a rock paper scissors game.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; game system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
499,"Design a system for an Alexa-enabled Peloton. Define the APIs, system architecture, and explain the various components.",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; IoT fitness,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
501,"Design a system that calculates the Peak-Period Price (surge pricing), given that it is calculated based on the number of opened apps (users) in some area divided by the number of drivers in the sa...",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; surge pricing algorithm,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: store and retrieve files reliably with high availability
  ğŸ“Š Success metric: upload/download speed, durability, storage cost, availability
  ğŸš« Non-goals: file versioning, sharing, search (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile apps uploading/downloading files
  ğŸ“¤ Upload service: handle file uploads, chunking, validation
  ğŸ’¾ Object storage: S3/GCS for file storage, metadata DB
  ğŸ”„ Replication: ensure durability across regions
  ğŸ“¥ CDN: cache popular files for fast downloads
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“¤ Upload: client â†’ upload service â†’ chunk file â†’ store in object storage â†’ update metadata
  ğŸ“¥ Download: client â†’ CDN check â†’ object storage â†’ stream to client
  â³ Async: file replication, thumbnail generation, virus scanning
  âŒ Failure: upload retry, partial upload resume, storage replication
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: upload/download speed, minimize time to first byte
  ğŸ”’ Consistency: strong consistency for metadata, eventual for replication
  ğŸ“ˆ Throughput: handle large files, concurrent uploads/downloads
  ğŸ’° Cost: optimize storage costs (tiering, compression, deduplication)
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: object storage I/O, metadata DB, network bandwidth
  âš ï¸ Single points: object storage, metadata DB, upload service
  ğŸš¦ Backpressure: rate limit uploads, queue large files, throttle downloads
  ğŸ’¨ Caching: CDN for popular files, cache metadata
  ğŸ”€ Sharding: shard by file_id, replicate across regions
  âš ï¸ Rule: Talk about failure BEFORE optimization"
502,Design a system that filters waste by detecting paper and putting it in the correct bin.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; waste sorting,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
503,Design a system that ingests book reviews from Amazon.com and provides book recommendations on your website.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; recommendation system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: surface relevant content/products to users based on preferences
  ğŸ“Š Success metric: click-through rate, engagement, relevance score, latency
  ğŸš« Non-goals: real-time updates, explainability, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile apps requesting recommendations
  ğŸ¯ Recommendation service: compute personalized rankings
  ğŸ‘¤ User profile store: user preferences, history, behavior
  ğŸ“¦ Item catalog: product/content metadata and features
  ğŸ¤– ML models: ranking algorithms, collaborative filtering, embeddings
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path: client â†’ API â†’ fetch user profile â†’ compute recommendations â†’ rank â†’ return
  âœï¸ Write path: user actions â†’ event stream â†’ update user profile â†’ retrain models (async)
  â³ Async: model training, feature computation, index updates
  âŒ Failure: model unavailable â†’ fallback to popularity-based, cache stale results
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: recommendations must be <100ms (user-facing)
  ğŸ”’ Consistency: eventual consistency OK (user profiles update async)
  ğŸ“ˆ Throughput: 1M requests/sec during peak, handle cold starts
  ğŸ’° Cost: balance model complexity vs inference cost
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: model inference, feature store lookups, ranking computation
  âš ï¸ Single points: model serving, feature store, user profile DB
  ğŸš¦ Backpressure: queue requests, return cached/stale recommendations
  ğŸ’¨ Caching: cache popular recommendations, pre-compute for hot users
  ğŸ”€ Sharding: shard user profiles, distribute model serving
  âš ï¸ Rule: Talk about failure BEFORE optimization"
504,Design a system that offers discounts to customers.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; discount system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
505,Design a system that recommends the next Confluence pages a user should view.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; recommendation system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: surface relevant content/products to users based on preferences
  ğŸ“Š Success metric: click-through rate, engagement, relevance score, latency
  ğŸš« Non-goals: real-time updates, explainability, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile apps requesting recommendations
  ğŸ¯ Recommendation service: compute personalized rankings
  ğŸ‘¤ User profile store: user preferences, history, behavior
  ğŸ“¦ Item catalog: product/content metadata and features
  ğŸ¤– ML models: ranking algorithms, collaborative filtering, embeddings
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path: client â†’ API â†’ fetch user profile â†’ compute recommendations â†’ rank â†’ return
  âœï¸ Write path: user actions â†’ event stream â†’ update user profile â†’ retrain models (async)
  â³ Async: model training, feature computation, index updates
  âŒ Failure: model unavailable â†’ fallback to popularity-based, cache stale results
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: recommendations must be <100ms (user-facing)
  ğŸ”’ Consistency: eventual consistency OK (user profiles update async)
  ğŸ“ˆ Throughput: 1M requests/sec during peak, handle cold starts
  ğŸ’° Cost: balance model complexity vs inference cost
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: model inference, feature store lookups, ranking computation
  âš ï¸ Single points: model serving, feature store, user profile DB
  ğŸš¦ Backpressure: queue requests, return cached/stale recommendations
  ğŸ’¨ Caching: cache popular recommendations, pre-compute for hot users
  ğŸ”€ Sharding: shard user profiles, distribute model serving
  âš ï¸ Rule: Talk about failure BEFORE optimization"
506,Design a system to communicate with a bank.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; banking integration,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
507,"Design a system to deny services to requests from banned IPs, as per information provided by security.gov.x.",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; security filtering,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
508,Design a system to detect bot players.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; bot detection,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
510,Design a system to log messages in order,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; logging system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: enable real-time communication between users reliably
  ğŸ“Š Success metric: message delivery latency, delivery guarantees, availability
  ğŸš« Non-goals: video calls, file sharing, group management (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: mobile apps, web clients sending/receiving messages
  ğŸ’¬ Message service: handle send, receive, delivery status
  ğŸ“¨ Message queue: Kafka/RabbitMQ for reliable delivery
  ğŸ’¾ Message store: database for message history and metadata
  ğŸ”” Presence service: track online/offline status, push notifications
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  âœï¸ Send: sender â†’ message service â†’ queue â†’ store â†’ push to recipient
  ğŸ“– Receive: recipient â†’ message service â†’ fetch from store â†’ deliver
  â³ Async: offline message delivery, read receipts, typing indicators
  âŒ Failure: message retry, dead letter queue, delivery status tracking
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: message delivery <1s for online users
  ğŸ”’ Consistency: at-least-once delivery guarantee, message ordering
  ğŸ“ˆ Throughput: 1M messages/sec, handle message bursts
  ğŸ’° Cost: optimize storage (message retention policies)
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: message queue, message store, push notification service
  âš ï¸ Single points: message queue, database, push service
  ğŸš¦ Backpressure: queue messages, rate limit sends, batch notifications
  ğŸ’¨ Caching: cache recent messages, user presence, connection state
  ğŸ”€ Sharding: shard by user_id, partition message queues
  âš ï¸ Rule: Talk about failure BEFORE optimization"
511,Design a system to map IP address ranges to geographic region labels.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; geolocation,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
512,Design a system to schedule jobs in a distributed environment.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; job scheduling,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
513,Design a system to store multiple images in a single file.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; file storage,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
514,Design a system to track reviews abuse on Amazon.com.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; abuse detection,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
515,Design a system to upgrade hundreds of thousands of machines on the Moon.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; remote deployment,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
518,Design a task management system with tasks broken into sub-tasks.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; task management,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
522,Design a Tic Tac Toe game that allows remote play.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; game system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
528,Design a truck tracking system that supports filtering by truck number and includes an interface for updating driver status.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; logistics tracking,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: store and retrieve files reliably with high availability
  ğŸ“Š Success metric: upload/download speed, durability, storage cost, availability
  ğŸš« Non-goals: file versioning, sharing, search (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile apps uploading/downloading files
  ğŸ“¤ Upload service: handle file uploads, chunking, validation
  ğŸ’¾ Object storage: S3/GCS for file storage, metadata DB
  ğŸ”„ Replication: ensure durability across regions
  ğŸ“¥ CDN: cache popular files for fast downloads
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“¤ Upload: client â†’ upload service â†’ chunk file â†’ store in object storage â†’ update metadata
  ğŸ“¥ Download: client â†’ CDN check â†’ object storage â†’ stream to client
  â³ Async: file replication, thumbnail generation, virus scanning
  âŒ Failure: upload retry, partial upload resume, storage replication
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: upload/download speed, minimize time to first byte
  ğŸ”’ Consistency: strong consistency for metadata, eventual for replication
  ğŸ“ˆ Throughput: handle large files, concurrent uploads/downloads
  ğŸ’° Cost: optimize storage costs (tiering, compression, deduplication)
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: object storage I/O, metadata DB, network bandwidth
  âš ï¸ Single points: object storage, metadata DB, upload service
  ğŸš¦ Backpressure: rate limit uploads, queue large files, throttle downloads
  ğŸ’¨ Caching: CDN for popular files, cache metadata
  ğŸ”€ Sharding: shard by file_id, replicate across regions
  âš ï¸ Rule: Talk about failure BEFORE optimization"
529,Design a typeahead box for a search engine.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; search autocomplete,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: quickly find relevant results from large datasets
  ğŸ“Š Success metric: search latency, relevance, result ranking quality
  ğŸš« Non-goals: autocomplete, spell correction, personalization (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: search UI, API consumers
  ğŸ” Search service: query processing, ranking, result assembly
  ğŸ“š Index: inverted index, document store, ranking data
  ğŸ”„ Indexer: crawl, parse, and build search indexes
  ğŸ’¨ Cache: popular queries, autocomplete suggestions
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
530,Design a URL shortener.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; URL shortening,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: shorten long URLs for sharing, trackability, and convenience
  ğŸ“Š Success metric: low latency redirects (<50ms), high availability, URL uniqueness
  ğŸš« Non-goals: URL expiration, custom aliases, analytics (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web browsers, mobile apps, API consumers
  ğŸ”— API gateway: handle shorten and redirect requests
  ğŸ†” ID generator: create unique short codes (base62, UUID, counter)
  ğŸ’¾ URL store: database mapping short_code â†’ long_url
  ğŸ’¨ Cache: Redis/CDN for hot redirects (read-heavy workload)
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  âœï¸ Write path: client â†’ API â†’ generate short_code â†’ store (DB) â†’ cache
  ğŸ“– Read path: client â†’ API â†’ cache lookup â†’ DB fallback â†’ redirect
  â³ Async: analytics pipeline (track clicks, generate reports)
  âŒ Failure: cache miss â†’ DB timeout â†’ return error or default
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: redirects must be <50ms (read-heavy, cache-first)
  ğŸ”’ Consistency: strong consistency on writes (URL uniqueness)
  ğŸ“ˆ Throughput: 100M redirects/day, 1K writes/sec
  ğŸ’° Cost: minimize storage (short codes are small), maximize cache hit rate
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB becomes bottleneck on writes, cache misses on reads
  âš ï¸ Single points: ID generator, database, cache
  ğŸš¦ Backpressure: rate limit writes, queue redirects if cache down
  ğŸ’¨ Caching: cache 80%+ of redirects, use CDN for global distribution
  ğŸ”€ Sharding: shard by short_code hash, replicate DB for reads
  âš ï¸ Rule: Talk about failure BEFORE optimization"
531,Design a user login system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; authentication,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
540,Design a visual landmark recognition system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; computer vision,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
542,Design a voting system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; voting system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
548,Design a web crawler.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; web crawling,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
549,Design a web scraping engine.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; web scraping,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
550,Design a web service for asynchronous communication.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; async communication,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
556,Design an AB test system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; experimentation platform,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
557,Design an agent that selects music based on real-world signals like weather.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; AI agent,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
558,Design an agentic AI system that can autonomously adapt to new tasks.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; AI agent,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
559,Design an agentic AI system to power customer support for Spotify.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; AI customer support,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
563,Design an airline booking system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; booking system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
569,Design an API for searching a folder.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; API design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: quickly find relevant results from large datasets
  ğŸ“Š Success metric: search latency, relevance, result ranking quality
  ğŸš« Non-goals: autocomplete, spell correction, personalization (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: search UI, API consumers
  ğŸ” Search service: query processing, ranking, result assembly
  ğŸ“š Index: inverted index, document store, ranking data
  ğŸ”„ Indexer: crawl, parse, and build search indexes
  ğŸ’¨ Cache: popular queries, autocomplete suggestions
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
584,Design an app where customer listening history is collected after they have listened to a song for more than 30 seconds for analytics use.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; analytics data collection,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
585,Design an Applicant Tracking System (ATS).,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; ATS,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
593,Design an ATM system that remains operational during natural disasters.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; disaster resilience,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
594,Design an ATS system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; ATS,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
595,Design an auto-complete feature.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; autocomplete,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
596,Design an automated comment moderation system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; content moderation,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
597,Design an automated reimbursement system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; reimbursement automation,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
602,Design an election system for the University of Washington.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; voting system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
608,Design an end-to-end batching system for LLM queries.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; LLM batching,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
609,Design an end-to-end ML solution to detect ads selling weapons.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; ML moderation,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
614,Design an experimentation platform for Google.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; experimentation platform,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
617,Design an indexer and a retriever,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; search indexer,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
618,"Design an inference batching system for a single GPU that can handle up to 100 inputs per batch while users wait synchronously, maximizing utilization under compute constraints.",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; ML inference,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
619,Design an internal navigation system for Cruise servicing garages.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; navigation system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
629,Design an online banking application.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; banking app,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
632,Design an open-source content management filtering system governed by a decentralized community.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; content filtering,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
633,Design an order-assignment system for early-stage last-mile food delivery app.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; logistics,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: deliver live content to viewers with low latency
  ğŸ“Š Success metric: stream latency, buffering rate, concurrent viewers, quality
  ğŸš« Non-goals: video on demand, chat, monetization (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: viewers on web, mobile, TV apps
  ğŸ¥ Encoder: transcode video to multiple quality levels
  ğŸ“¡ CDN: deliver video chunks to viewers globally
  ğŸ“Š Analytics: track views, engagement, quality metrics
  ğŸ’¾ Origin server: store master video files
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
634,"Design and implement a system to manage a voice-dubbing workflow, replacing an Excel-based process. Given operations for editing, reviewing, and approving voice lines, correctly track status change...",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; workflow management,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
637,Design APIs for Facebook live commenting.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; API design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: deliver live content to viewers with low latency
  ğŸ“Š Success metric: stream latency, buffering rate, concurrent viewers, quality
  ğŸš« Non-goals: video on demand, chat, monetization (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: viewers on web, mobile, TV apps
  ğŸ¥ Encoder: transcode video to multiple quality levels
  ğŸ“¡ CDN: deliver video chunks to viewers globally
  ğŸ“Š Analytics: track views, engagement, quality metrics
  ğŸ’¾ Origin server: store master video files
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
639,Design browser history.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; browser feature,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
641,Design Dropbox.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; file storage,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: store and retrieve files reliably with high availability
  ğŸ“Š Success metric: upload/download speed, durability, storage cost, availability
  ğŸš« Non-goals: file versioning, sharing, search (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile apps uploading/downloading files
  ğŸ“¤ Upload service: handle file uploads, chunking, validation
  ğŸ’¾ Object storage: S3/GCS for file storage, metadata DB
  ğŸ”„ Replication: ensure durability across regions
  ğŸ“¥ CDN: cache popular files for fast downloads
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“¤ Upload: client â†’ upload service â†’ chunk file â†’ store in object storage â†’ update metadata
  ğŸ“¥ Download: client â†’ CDN check â†’ object storage â†’ stream to client
  â³ Async: file replication, thumbnail generation, virus scanning
  âŒ Failure: upload retry, partial upload resume, storage replication
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: upload/download speed, minimize time to first byte
  ğŸ”’ Consistency: strong consistency for metadata, eventual for replication
  ğŸ“ˆ Throughput: handle large files, concurrent uploads/downloads
  ğŸ’° Cost: optimize storage costs (tiering, compression, deduplication)
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: object storage I/O, metadata DB, network bandwidth
  âš ï¸ Single points: object storage, metadata DB, upload service
  ğŸš¦ Backpressure: rate limit uploads, queue large files, throttle downloads
  ğŸ’¨ Caching: CDN for popular files, cache metadata
  ğŸ”€ Sharding: shard by file_id, replicate across regions
  âš ï¸ Rule: Talk about failure BEFORE optimization"
643,Design Facebook Marketplace.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; marketplace,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
644,Design Facebook Messenger.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; messaging,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: enable real-time communication between users reliably
  ğŸ“Š Success metric: message delivery latency, delivery guarantees, availability
  ğŸš« Non-goals: video calls, file sharing, group management (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: mobile apps, web clients sending/receiving messages
  ğŸ’¬ Message service: handle send, receive, delivery status
  ğŸ“¨ Message queue: Kafka/RabbitMQ for reliable delivery
  ğŸ’¾ Message store: database for message history and metadata
  ğŸ”” Presence service: track online/offline status, push notifications
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  âœï¸ Send: sender â†’ message service â†’ queue â†’ store â†’ push to recipient
  ğŸ“– Receive: recipient â†’ message service â†’ fetch from store â†’ deliver
  â³ Async: offline message delivery, read receipts, typing indicators
  âŒ Failure: message retry, dead letter queue, delivery status tracking
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: message delivery <1s for online users
  ğŸ”’ Consistency: at-least-once delivery guarantee, message ordering
  ğŸ“ˆ Throughput: 1M messages/sec, handle message bursts
  ğŸ’° Cost: optimize storage (message retention policies)
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: message queue, message store, push notification service
  âš ï¸ Single points: message queue, database, push service
  ğŸš¦ Backpressure: queue messages, rate limit sends, batch notifications
  ğŸ’¨ Caching: cache recent messages, user presence, connection state
  ğŸ”€ Sharding: shard by user_id, partition message queues
  âš ï¸ Rule: Talk about failure BEFORE optimization"
645,Design Google Docs.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; collaboration tool,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
646,Design Google Drive.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; cloud storage,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: store and retrieve files reliably with high availability
  ğŸ“Š Success metric: upload/download speed, durability, storage cost, availability
  ğŸš« Non-goals: file versioning, sharing, search (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile apps uploading/downloading files
  ğŸ“¤ Upload service: handle file uploads, chunking, validation
  ğŸ’¾ Object storage: S3/GCS for file storage, metadata DB
  ğŸ”„ Replication: ensure durability across regions
  ğŸ“¥ CDN: cache popular files for fast downloads
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“¤ Upload: client â†’ upload service â†’ chunk file â†’ store in object storage â†’ update metadata
  ğŸ“¥ Download: client â†’ CDN check â†’ object storage â†’ stream to client
  â³ Async: file replication, thumbnail generation, virus scanning
  âŒ Failure: upload retry, partial upload resume, storage replication
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: upload/download speed, minimize time to first byte
  ğŸ”’ Consistency: strong consistency for metadata, eventual for replication
  ğŸ“ˆ Throughput: handle large files, concurrent uploads/downloads
  ğŸ’° Cost: optimize storage costs (tiering, compression, deduplication)
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: object storage I/O, metadata DB, network bandwidth
  âš ï¸ Single points: object storage, metadata DB, upload service
  ğŸš¦ Backpressure: rate limit uploads, queue large files, throttle downloads
  ğŸ’¨ Caching: CDN for popular files, cache metadata
  ğŸ”€ Sharding: shard by file_id, replicate across regions
  âš ï¸ Rule: Talk about failure BEFORE optimization"
648,Design Google Street View using 1000 cars to map every address and image worldwide.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; mapping system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
650,Design Instagram.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; social platform,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
652,Design live commenting for Facebook.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; real-time features,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: deliver live content to viewers with low latency
  ğŸ“Š Success metric: stream latency, buffering rate, concurrent viewers, quality
  ğŸš« Non-goals: video on demand, chat, monetization (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: viewers on web, mobile, TV apps
  ğŸ¥ Encoder: transcode video to multiple quality levels
  ğŸ“¡ CDN: deliver video chunks to viewers globally
  ğŸ“Š Analytics: track views, engagement, quality metrics
  ğŸ’¾ Origin server: store master video files
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
659,Design PasteBin.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; paste service,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
665,Design spam detection on Pinterest.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; spam detection,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
668,Design the architecture for a hardware device that measures temperature and social distance among employees in warehouses during COVID.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; IoT device,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
670,Design the architecture to send chargeback transactions to Visa.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; payment processing,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: process transactions securely and reliably
  ğŸ“Š Success metric: transaction success rate, latency, fraud detection, availability
  ğŸš« Non-goals: refunds, disputes, multi-currency (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: merchants, payment gateways, mobile apps
  ğŸ’³ Payment processor: authorize, capture, settle transactions
  ğŸ¦ Bank gateway: communicate with payment networks
  ğŸ”’ Fraud detection: ML models to detect suspicious transactions
  ğŸ’¾ Transaction store: database for transaction history, reconciliation
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
671,Design the backend architecture for Spotify.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; music streaming,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
678,Design the recommendation engine for Amazon's homepage.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; recommendation engine,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: surface relevant content/products to users based on preferences
  ğŸ“Š Success metric: click-through rate, engagement, relevance score, latency
  ğŸš« Non-goals: real-time updates, explainability, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile apps requesting recommendations
  ğŸ¯ Recommendation service: compute personalized rankings
  ğŸ‘¤ User profile store: user preferences, history, behavior
  ğŸ“¦ Item catalog: product/content metadata and features
  ğŸ¤– ML models: ranking algorithms, collaborative filtering, embeddings
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path: client â†’ API â†’ fetch user profile â†’ compute recommendations â†’ rank â†’ return
  âœï¸ Write path: user actions â†’ event stream â†’ update user profile â†’ retrain models (async)
  â³ Async: model training, feature computation, index updates
  âŒ Failure: model unavailable â†’ fallback to popularity-based, cache stale results
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: recommendations must be <100ms (user-facing)
  ğŸ”’ Consistency: eventual consistency OK (user profiles update async)
  ğŸ“ˆ Throughput: 1M requests/sec during peak, handle cold starts
  ğŸ’° Cost: balance model complexity vs inference cost
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: model inference, feature store lookups, ranking computation
  âš ï¸ Single points: model serving, feature store, user profile DB
  ğŸš¦ Backpressure: queue requests, return cached/stale recommendations
  ğŸ’¨ Caching: cache popular recommendations, pre-compute for hot users
  ğŸ”€ Sharding: shard user profiles, distribute model serving
  âš ï¸ Rule: Talk about failure BEFORE optimization"
679,Design the SMS API for Twilio.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; API design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
680,Design the system for a ticket selling web application.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; ticketing system,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
681,Design Ticketmaster,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; ticketing platform,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
684,Design Twitter.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; social platform,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
685,Design type-ahead search for walmart.com.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; search autocomplete,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: quickly find relevant results from large datasets
  ğŸ“Š Success metric: search latency, relevance, result ranking quality
  ğŸš« Non-goals: autocomplete, spell correction, personalization (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: search UI, API consumers
  ğŸ” Search service: query processing, ranking, result assembly
  ğŸ“š Index: inverted index, document store, ranking data
  ğŸ”„ Indexer: crawl, parse, and build search indexes
  ğŸ’¨ Cache: popular queries, autocomplete suggestions
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
686,Design typeahead autocomplete for person search in Linkedin.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; search autocomplete,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: quickly find relevant results from large datasets
  ğŸ“Š Success metric: search latency, relevance, result ranking quality
  ğŸš« Non-goals: autocomplete, spell correction, personalization (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: search UI, API consumers
  ğŸ” Search service: query processing, ranking, result assembly
  ğŸ“š Index: inverted index, document store, ranking data
  ğŸ”„ Indexer: crawl, parse, and build search indexes
  ğŸ’¨ Cache: popular queries, autocomplete suggestions
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
687,Design Uber Eats.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System design; food delivery,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
732,"Draw the system for which one of your programs was responsible. Discuss the different components, how they interact, and the technical decisions made.",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System explanation; behavioral question,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
797,Explain how microservices work.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System explanation; architecture,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
807,Explain in detail the architecture of the platform you're working on.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System explanation; behavioral question,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
991,Go into detail about a login endpoint.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API design; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1074,"How do you decide whether a problem should be solved using AI, generative AI, an agent-based system, traditional programming, or just a simple rule-based approach?",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Solution selection; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1095,How do you evaluate a Gen AI system?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,AI evaluation; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1227,"How will you address your API limits? Describe all possible scenarios regarding customers, technology, and suppliers.",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API limits; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1264,How would you build a system for running experiments such as A/B tests on an app or website?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,A/B testing system; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1451,How would you improve YouTube's recommendation algorithm?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Recommendation algorithm; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: surface relevant content/products to users based on preferences
  ğŸ“Š Success metric: click-through rate, engagement, relevance score, latency
  ğŸš« Non-goals: real-time updates, explainability, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile apps requesting recommendations
  ğŸ¯ Recommendation service: compute personalized rankings
  ğŸ‘¤ User profile store: user preferences, history, behavior
  ğŸ“¦ Item catalog: product/content metadata and features
  ğŸ¤– ML models: ranking algorithms, collaborative filtering, embeddings
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path: client â†’ API â†’ fetch user profile â†’ compute recommendations â†’ rank â†’ return
  âœï¸ Write path: user actions â†’ event stream â†’ update user profile â†’ retrain models (async)
  â³ Async: model training, feature computation, index updates
  âŒ Failure: model unavailable â†’ fallback to popularity-based, cache stale results
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: recommendations must be <100ms (user-facing)
  ğŸ”’ Consistency: eventual consistency OK (user profiles update async)
  ğŸ“ˆ Throughput: 1M requests/sec during peak, handle cold starts
  ğŸ’° Cost: balance model complexity vs inference cost
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: model inference, feature store lookups, ranking computation
  âš ï¸ Single points: model serving, feature store, user profile DB
  ğŸš¦ Backpressure: queue requests, return cached/stale recommendations
  ğŸ’¨ Caching: cache popular recommendations, pre-compute for hot users
  ğŸ”€ Sharding: shard user profiles, distribute model serving
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1715,List 3 endpoints on theScore app.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1716,List an example of one endpoint on Twitch.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: deliver live content to viewers with low latency
  ğŸ“Š Success metric: stream latency, buffering rate, concurrent viewers, quality
  ğŸš« Non-goals: video on demand, chat, monetization (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: viewers on web, mobile, TV apps
  ğŸ¥ Encoder: transcode video to multiple quality levels
  ğŸ“¡ CDN: deliver video chunks to viewers globally
  ğŸ“Š Analytics: track views, engagement, quality metrics
  ğŸ’¾ Origin server: store master video files
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1717,List five different APIs offered by Spotify.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1718,List four endpoints on Tinder.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1721,List three endpoints on edX.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1722,List three endpoints on Top Hat.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1849,System Design: Design an AirTag system.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,AirTag system; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
1886,Tell me about a system you are currently working on.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System description; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2008,Tell me about a time when you were involved in system architecture. What components were involved and what was your role?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System architecture; behavioral question,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2109,Tell me about the design and architecture of the program you managed. Explain the system end-to-end and various technologies you picked with reason.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,System architecture; behavioral question,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: serve ML models with low latency and high accuracy
  ğŸ“Š Success metric: inference latency, model accuracy, throughput, cost per prediction
  ğŸš« Non-goals: model training, feature engineering, A/B testing (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: applications making inference requests
  ğŸ¤– Model serving: load models, handle inference requests
  ğŸ“Š Feature store: serve features for model input
  âš™ï¸ Preprocessing: data transformation, feature engineering
  ğŸ“ˆ Monitoring: track model performance, drift, latency
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2185,Walk me through the technical architecture of your product.,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Technical architecture; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2201,What are some endpoints on Amazon.com?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2202,What are some endpoints Robinhood has?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2236,What are three APIs on theScore's mobile app?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2238,What are three endpoints on Discord?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2239,What are three endpoints on Wayfair?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2240,What are three endpoints on YouTube?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoints; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2279,What does the Signup endpoint on Facebook do?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API endpoint; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2310,What is a Medallion Architecture?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Data architecture; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2316,What is an API and how does it work?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API explanation; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2328,What is the best way to connect SQL databases and why?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Database connection; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2445,What technical components are needed to implement spending limits for virtual debit cards?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Technical components; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2457,What types of indexes are in a relational database?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Database indexes; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2487,What's the difference between an API and an SDK?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,API vs SDK; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2516,What's the difference between the Kubernetes control plane and data plane?,ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Kubernetes; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: what is the main user need or business objective?
  ğŸ“Š Success metric: latency, reliability, accuracy, cost, what defines success?
  ğŸš« Non-goals: explicitly say what's out of scope, what we're NOT building
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: web, mobile, internal tools, what are the entry points?
  ğŸ“¥ Ingestion: APIs, SDKs, event collectors, how does data enter?
  âš™ï¸ Processing: sync vs async, how is data processed?
  ğŸ’¾ Storage: hot / warm / cold, where is data stored?
  ğŸ–¥ï¸ Compute: stateless vs stateful, how is computation handled?
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  ğŸ“– Request path (read): how do read requests flow through the system?
  âœï¸ Write path (create/update): how do write requests flow through?
  â³ Async paths: queues, streams, retries, how are async ops handled?
  âŒ Failure paths: timeouts, backpressure, how are failures handled?
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency SLOs: what are the latency requirements?
  ğŸ”’ Consistency: strong vs eventual consistency?
  ğŸ“ˆ Throughput: how many requests per second must we handle?
  ğŸ’° Cost ceilings: what are the budget constraints?
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: DB, network, fan-out, where will it slow down?
  âš ï¸ Single points of failure: what components have no redundancy?
  ğŸš¦ Backpressure: how do we handle overload?
  ğŸ’¨ Caching: where can we cache to reduce load?
  ğŸ”€ Sharding / partitioning: how do we distribute data?
  âš ï¸ Rule: Talk about failure BEFORE optimization"
2519,"When designing a chat application, how would you decide between using SQL and NoSQL databases?",ğŸŸ¡,L14_General,System Design - General,Components â†’ Data Flow â†’ Boundaries â†’ Scale Considerations,Database choice; system design,"ğŸ¯ Define the GOAL: Clarify what problem we're solving
  ğŸ‘¥ Primary user goal: enable real-time communication between users reliably
  ğŸ“Š Success metric: message delivery latency, delivery guarantees, availability
  ğŸš« Non-goals: video calls, file sharing, group management (initially)
  âš ï¸ Rule: If the goal isn't clear, architecture will be wrong

ğŸ§© Identify CORE COMPONENTS: Define what blocks exist
  ğŸ“± Clients: mobile apps, web clients sending/receiving messages
  ğŸ’¬ Message service: handle send, receive, delivery status
  ğŸ“¨ Message queue: Kafka/RabbitMQ for reliable delivery
  ğŸ’¾ Message store: database for message history and metadata
  ğŸ”” Presence service: track online/offline status, push notifications
  âš ï¸ Rule: Name boxes before wiring arrows

ğŸ”„ Data FLOW: Describe how data moves end-to-end
  âœï¸ Send: sender â†’ message service â†’ queue â†’ store â†’ push to recipient
  ğŸ“– Receive: recipient â†’ message service â†’ fetch from store â†’ deliver
  â³ Async: offline message delivery, read receipts, typing indicators
  âŒ Failure: message retry, dead letter queue, delivery status tracking
  âš ï¸ Rule: Always describe the happy path first

ğŸš§ Boundaries & CONSTRAINTS: Identify what limits us
  â±ï¸ Latency: message delivery <1s for online users
  ğŸ”’ Consistency: at-least-once delivery guarantee, message ordering
  ğŸ“ˆ Throughput: 1M messages/sec, handle message bursts
  ğŸ’° Cost: optimize storage (message retention policies)
  âš ï¸ Rule: Constraints shape architecture more than features

ğŸ“ˆ Scale & FAILURE MODES: Consider what breaks at 10Ã—
  ğŸŒ Bottlenecks: message queue, message store, push notification service
  âš ï¸ Single points: message queue, database, push service
  ğŸš¦ Backpressure: queue messages, rate limit sends, batch notifications
  ğŸ’¨ Caching: cache recent messages, user presence, connection state
  ğŸ”€ Sharding: shard by user_id, partition message queues
  âš ï¸ Rule: Talk about failure BEFORE optimization"
