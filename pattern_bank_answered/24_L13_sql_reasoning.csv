question_id,question_text,priority,pattern_id,pattern_name,solving_formula,notes,short_answer
736,Employee Earnings.,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; employee data,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
737,Employee Hierarchy,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; hierarchical data,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  ğŸ”— Multiple joins: ensure join keys are correct and understand relationships
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
832,Explain the key differences between BETWEEN and HAVING clauses in SQL.,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL explanation; query optimization,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
848,Extract and clean a usable dataset from a provided company demo database using only SQL and Python.,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,Data extraction; SQL + Python,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
854,Find Campaign Purchases,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; campaign analysis,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
886,Find the number of users who called three or more people in the last week.,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; user analysis,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  â° Time-based: filter to the specified time window (last week, last month, etc.)
  ğŸ”¢ Conditional filters: use HAVING or subqueries for conditions on aggregated results
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
897,Fraudulent Transactions,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; fraud detection,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
899,Get the top API users based on transaction logs.,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; API usage analysis,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  ğŸ† Ranking: top N, highest/lowest, how are we ranking results?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  ğŸ† Ranking: use window functions (ROW_NUMBER, RANK, DENSE_RANK) or ORDER BY + LIMIT for top N
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
911,"Given a bookstore database schema, write SQL queries using joins and aggregations to answer questions about sales, inventory, and customer data.",ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; database schema,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  ğŸ”— Multiple joins: ensure join keys are correct and understand relationships
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
2645,Write a query to find all dates where the stadium had three or more consecutive days with attendance of 100 or more people.,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; conceptual reasoning,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  â° Time-based: filter to the specified time window (last week, last month, etc.)
  ğŸ”¢ Conditional filters: use HAVING or subqueries for conditions on aggregated results
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  ğŸ”„ Consecutive logic: use window functions (LAG, LEAD) or self-joins to identify consecutive patterns
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
2646,Write a query to find the top 3 unique salaries in each department and list all employees who have those salaries.,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; conceptual reasoning,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  ğŸ† Ranking: top N, highest/lowest, how are we ranking results?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  ğŸ† Ranking: use window functions (ROW_NUMBER, RANK, DENSE_RANK) or ORDER BY + LIMIT for top N
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
2647,Write a SQL query to identify the least efficient driver in terms of deliveries per time spent driving in the last two months using the given dataset.,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; conceptual reasoning,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  ğŸ† Ranking: top N, highest/lowest, how are we ranking results?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  â° Time-based: filter to the specified time window (last week, last month, etc.)
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  ğŸ† Ranking: use window functions (ROW_NUMBER, RANK, DENSE_RANK) or ORDER BY + LIMIT for top N
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
2648,Write a SQL query to sum the number of rides and deliveries completed for each zip code using the given dataset.,ğŸŸ¡,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,SQL query; conceptual reasoning,"ğŸ“Š Define the OUTPUT: Specify what the final table should look like
  ğŸ¯ Grain: one row per what? (user / order / day / experiment / cohort / department / zip code)
  ğŸ“‹ Columns: metrics + dimensions, what metrics do we need? What dimensions to group by?
  ğŸ“… Time window: last 7d, 30d, all-time, what time period are we analyzing?
  âš ï¸ Rule: If you can't say the grain, you don't understand the query

ğŸ”— Conceptual JOIN: Identify what data must come together
  ğŸ“Š Fact table: events, orders, transactions, what is the base table with the metrics?
  ğŸ·ï¸ Dimension tables: users, products, dates, what tables provide context or attributes?
  ğŸ”‘ Join keys: user_id, order_id, product_id, what columns link the tables together?
  ğŸ”€ Join type: INNER â†’ only matched rows, LEFT â†’ keep base table intact
  âš ï¸ Rule: Pick the BASE table first, then join outward

ğŸ” Filter Logic: Determine which rows count
  ğŸ“… Time filters: event_date BETWEEN â€¦, date >= â€¦, what time period are we filtering?
  âœ… Status filters: completed, paid, active, what status or state conditions?
  ğŸ‘¥ Segment filters: country, platform, plan, what demographic or segment filters?
  ğŸš« Exclusions: test users, refunds, bots, what should we exclude?
  âš ï¸ Rule: Filters change meaning â€” say them explicitly

ğŸ§® Aggregation Logic: Determine how numbers are computed
  ğŸ”¢ Count vs count distinct: COUNT(*) counts all rows, COUNT(DISTINCT column) counts unique values
  â• Sum vs average: SUM for totals, AVG for averages, what aggregation function is appropriate?
  ğŸ“Š Group by: which dimensions? What columns determine the grain of the output?
  âš ï¸ Rule: Aggregation happens at the grain, not before

âœ… Edge Cases & Validation: Check for potential issues
  ğŸ”„ Duplicates after joins? Do joins create duplicate rows that will inflate counts?
  â“ Missing data? Are there NULL values that need handling?
  ğŸ” Sanity checks: back-of-envelope validation, do the numbers make sense?
  ğŸ“ˆ Performance: for large datasets, consider if the query will be efficient (indexes, filtering early)
  ğŸ§ª Test edge cases: empty results, single row, all NULLs, what happens in edge cases?"
1278,How would you convey insights and the methods used to a non-technical audience?,ğŸŸ¢,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,Insight communication; data translation,
1869,Tell me about a project when you had to translate data into insights for the team/client you were working with.,ğŸŸ¢,L13,SQL Reasoning,Conceptual Join â†’ Aggregation Logic â†’ Filter Logic â†’ Output,Data translation; data translation,
